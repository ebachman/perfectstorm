#!/usr/bin/env python3
# Copyright (c) 2018, Andrea Corbellini
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are those
# of the authors and should not be interpreted as representing official policies,
# either expressed or implied, of the Perfect Storm Project.

import abc
import argparse
import collections
import functools
import re
import sys

import yaml

from perfectstorm import (
    Agent,
    Application,
    Group,
    Recipe,
    Resource,
    Trigger,
)
from perfectstorm.cli import CommandLineClient


def _dict_representer(dumper, data):
    return dumper.represent_dict(data.items())


yaml.add_representer(collections.OrderedDict, _dict_representer)


def yaml_load(arg):
    return yaml.safe_load(arg)


def yaml_dump(arg):
    return yaml.dump(arg, sys.stdout, default_flow_style=False)


def get_object_id(obj):
    return str(obj.id)


def get_object_type(obj):
    return str(obj.type)


def get_object_name(obj):
    if getattr(obj, 'name', None):
        name = obj.name
    elif getattr(obj, 'names', None):
        name = obj.names
    else:
        name = obj.id

    if isinstance(name, list):
        name = ', '.join(str(item) for item in name)

    return str(name)


def get_object_status(obj):
    return obj.status or 'unknown'


def print_table(cols, rows):
    cols = list(cols)
    rows = list(rows)

    columns_len = {}

    for column in cols:
        columns_len[column] = len(column)

    for row in rows:
        for column, value in zip(cols, row):
            columns_len[column] = max(columns_len[column], len(value))

    row_format = '   '.join(
        '{: <%d}' % columns_len[column]
        for column in cols)

    table = [cols] + rows

    for row in table:
        print(row_format.format(*row))


class Command(metaclass=abc.ABCMeta):

    @property
    @abc.abstractmethod
    def command_name(self):
        raise NotImplementedError

    def add_arguments(self, parser):
        pass


class TopLevelCommand(Command):

    @abc.abstractmethod
    def __call__(self, client):
        raise NotImplementedError


class EntityCommand(Command):

    @abc.abstractmethod
    def __call__(self, client, model):
        raise NotImplementedError

    def get_queryset(self, client, model):
        return model.objects.all()


class SingleEntityCommand(EntityCommand):

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument('id')

    def get_object(self, client, model):
        obj = model(pk=client.options.id)
        obj.reload()
        return obj


class MultipleEntitiesCommand(EntityCommand):

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument('id', nargs='+')

    def iter_objects(self, client, model):
        for pk in client.options.id:
            obj = model(pk=pk)
            obj.reload()
            yield obj


class EntityImporter:

    def __call__(self, client, data, model):
        model(**data).save()


class ListCommandMixin:

    def __init__(self, columns, **kwargs):
        super().__init__(**kwargs)
        self.columns = columns

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument('-q', '--quiet', action='store_true')

    def __call__(self, client, model):
        qs = self.get_queryset(client, model)

        if client.options.quiet:
            self.list_quiet(qs)
        else:
            self.list_verbose(qs)

    def list_quiet(self, queryset):
        for obj in queryset:
            print(get_object_id(obj))

    def list_verbose(self, queryset):
        header = [column_name for column_name, getter in self.columns]
        rows = [
            [getter(obj) for column_name, getter in self.columns]
            for obj in queryset
        ]
        print_table(header, rows)


class EntityListCommand(ListCommandMixin, EntityCommand):

    command_name = 'ls'


class EntityGetCommand(SingleEntityCommand):

    command_name = 'get'

    def __call__(self, client, model):
        obj = self.get_object(client, model)

        data = collections.OrderedDict()
        for name in obj._fields:
            data[name] = getattr(obj, name)

        yaml_dump(data)


class EntityRemoveCommand(MultipleEntitiesCommand):

    command_name = 'rm'

    def __call__(self, client, model):
        for obj in self.iter_objects(client, model):
            obj.delete()


class EntityHandler(metaclass=abc.ABCMeta):

    importer = None

    @property
    @abc.abstractmethod
    def model(self):
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def entity_name(self):
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def commands(self):
        raise NotImplementedError

    def add_arguments(self, parser):
        subparsers = parser.add_subparsers(dest='command')
        for command in self.commands:
            command_parser = subparsers.add_parser(command.command_name)
            command_parser.set_defaults(command=functools.partial(command, model=self.model))
            command.add_arguments(command_parser)


class ImportCommand(TopLevelCommand):

    command_name = 'import'

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument('-f', '--file', type=argparse.FileType(), required=True)

    def __call__(self, client):
        with client.options.file as fp:
            document = yaml_load(fp)

        if isinstance(document, list):
            self.import_all(client, document)
        else:
            self.import_one(client, document)

    def import_all(self, client, lst):
        for item in lst:
            self.import_one(client, item)

    def import_one(self, client, spec):
        if not isinstance(spec, dict):
            raise TypeError(type(spec).__name__)
        if not spec:
            raise ValueError('Empty specification')
        if len(spec) > 1:
            raise ValueError('Too many items')

        entity_name, = spec
        entity_spec = spec[entity_name]

        for entity_handler in client.entity_handlers:
            if entity_handler.entity_name == entity_name and entity_handler.importer is not None:
                entity_handler.importer(client, data=entity_spec, model=entity_handler.model)
                return

        raise ValueError(entity_name)


class ApplicationImporter(EntityImporter):

    def __call__(self, client, data, model):
        api_data = self.parse(data)
        super().__call__(client, api_data, model)

    def parse(self, data):
        result = {}

        if 'name' in data:
            result['name'] = data['name']

        if 'components' in data:
            components = set()
            links = []

            for link_spec in data['components']:
                src_component, dest_component, dest_service = self.parse_component_link(link_spec)
                components.add(src_component)
                components.add(dest_component)
                links.append({'src_component': src_component, 'dest_component': dest_component, 'dest_service': dest_service})

            result['components'] = list(components)
            result['links'] = links

        if 'expose' in data:
            expose = []

            for service_spec in data['expose']:
                component, service = self.parse_exposed_service(service_spec)
                expose.append({'component': component, 'service': service})

            result['expose'] = expose

        return result

    def parse_component_link(self, link_spec):
        match = re.match(r'^\s*([\w._-]+)\s*=>\s*([\w._-]+)\s*\[\s*([\w._-]+)\s*\]\s*$', link_spec)
        return match.groups()

    def parse_exposed_service(self, service_spec):
        match = re.match(r'^\s*([\w._-]+)\s*\[\s*([\w._-]+)\s*\]\s*$', service_spec)
        return match.groups()


class AgentHandler(EntityHandler):

    model = Agent
    entity_name = 'agent'

    commands = [
        EntityListCommand([
            ('ID', get_object_id)
        ]),
        EntityGetCommand(),
    ]


class ApplicationHandler(EntityHandler):

    model = Application
    entity_name = 'application'

    commands = [
        EntityListCommand([
            ('ID', get_object_id),
            ('NAME', get_object_name),
        ]),
        EntityGetCommand(),
        EntityRemoveCommand(),
    ]

    importer = ApplicationImporter()


class ListGroupMembersCommand(ListCommandMixin, SingleEntityCommand):

    command_name = 'members'

    def get_queryset(self, client, model):
        obj = self.get_object(client, model)
        return obj.members()


class GroupHandler(EntityHandler):

    model = Group
    entity_name = 'group'

    commands = [
        EntityListCommand([
            ('ID', get_object_id),
            ('NAME', get_object_name),
        ]),
        EntityGetCommand(),
        ListGroupMembersCommand([
            ('ID', get_object_id),
            ('TYPE', get_object_type),
            ('NAMES', get_object_name),
        ]),
        EntityRemoveCommand(),
    ]

    importer = EntityImporter()


class RecipeHandler(EntityHandler):

    model = Recipe
    entity_name = 'recipe'

    commands = [
        EntityListCommand([
            ('ID', get_object_id),
            ('TYPE', get_object_type),
            ('NAME', get_object_name),
        ]),
        EntityGetCommand(),
        EntityRemoveCommand(),
    ]

    importer = EntityImporter()


class ResourceHandler(EntityHandler):

    model = Resource
    entity_name = 'resource'

    commands = [
        EntityListCommand([
            ('ID', get_object_id),
            ('TYPE', get_object_type),
            ('NAMES', get_object_name),
        ]),
        EntityGetCommand(),
    ]


class TriggerRunCommand(EntityCommand):

    command_name = 'run'

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument('-d', '--detach', action='store_true')
        parser.add_argument('-k', '--keep', action='store_true')
        parser.add_argument('-t', '--type', required=True)
        parser.add_argument('arguments', metavar='ARGUMENT[=VALUE]', type=self._parse_trigger_arg, nargs='*')

    def _parse_trigger_arg(self, arg):
        parts = arg.split('=', 1)
        if len(parts) == 1:
            return {arg: True}
        else:
            key, value = parts
            return {key: yaml_load(value)}

    def __call__(self, client, model):
        arguments = {}
        for arg in client.options.arguments:
            arguments.update(arg)

        obj = model(type=client.options.type, arguments=arguments)
        obj.save()

        if not client.options.detach:
            obj.wait(delete=not client.options.keep)


class TriggerHandler(EntityHandler):

    model = Trigger
    entity_name = 'trigger'

    commands = [
        EntityListCommand([
            ('ID', get_object_id),
            ('TYPE', get_object_type),
            ('STATUS', get_object_status),
        ]),
        EntityGetCommand(),
        EntityRemoveCommand(),
        TriggerRunCommand(),
    ]


class StormCtl(CommandLineClient):

    top_level_commands = [
        ImportCommand(),
    ]

    entity_handlers = [
        AgentHandler(),
        ApplicationHandler(),
        GroupHandler(),
        RecipeHandler(),
        ResourceHandler(),
        TriggerHandler(),
    ]

    def add_arguments(self, parser):
        super().add_arguments(parser)

        subparsers = parser.add_subparsers(dest='command')

        for command in self.top_level_commands:
            command_parser = subparsers.add_parser(command.command_name)
            command_parser.set_defaults(command=command)
            command.add_arguments(command_parser)

        for entity in self.entity_handlers:
            entity_parser = subparsers.add_parser(entity.entity_name)
            entity_parser.set_defaults(entity=entity)
            entity.add_arguments(entity_parser)

    def run(self):
        command = self.options.command
        command(self)


if __name__ == '__main__':
    StormCtl.main()
