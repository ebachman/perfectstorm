#!/usr/bin/env python3

import abc
import argparse
import functools
import re
import sys
from operator import attrgetter

import yaml

from perfectstorm import (
    Agent,
    Application,
    Group,
    Procedure,
    Resource,
    Trigger,
)
from perfectstorm.base import Model
from perfectstorm.cli import CommandLineClient


def _model_representer(dumper, obj):
    items = [(name, getattr(obj, name)) for name in obj._fields]
    return dumper.represent_dict(items)


yaml.add_multi_representer(Model, _model_representer)


def yaml_load(arg):
    return yaml.safe_load(arg)


def yaml_dump(arg):
    return yaml.dump(arg, sys.stdout, default_flow_style=False)


def ellipsise(s, max_length):
    if len(s) > max_length:
        s = s[:max_length - 3] + '...'
    return s


def get_object_id(obj):
    return str(obj.id)


def get_object_type(obj):
    return str(obj.type)


def get_object_name(obj, max_length=50):
    if getattr(obj, 'name', None):
        name = obj.name
    elif getattr(obj, 'names', None):
        name = obj.names
    else:
        name = obj.id

    if isinstance(name, list):
        name = ', '.join(str(item) for item in name)

    if max_length:
        name = ellipsise(name, max_length)

    return str(name)


def get_object_status(obj):
    return obj.status or 'unknown'


def print_table(cols, rows):
    cols = list(cols)
    rows = list(rows)

    columns_len = {}

    for column in cols:
        columns_len[column] = len(column)

    for row in rows:
        for column, value in zip(cols, row):
            columns_len[column] = max(columns_len[column], len(value))

    row_format = '   '.join(
        '{: <%d}' % columns_len[column]
        for column in cols)

    table = [cols] + rows

    for row in table:
        print(row_format.format(*row))


class Command(metaclass=abc.ABCMeta):

    @property
    @abc.abstractmethod
    def command_name(self):
        raise NotImplementedError

    def add_arguments(self, parser):
        pass


class TopLevelCommand(Command):

    @abc.abstractmethod
    def __call__(self, client):
        raise NotImplementedError


class EntityCommand(Command):

    @abc.abstractmethod
    def __call__(self, client, model):
        raise NotImplementedError

    def get_queryset(self, client, model):
        return model.objects.all()


class SingleEntityCommand(EntityCommand):

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument('id')

    def get_object(self, client, model):
        return model.objects.get(client.options.id)


class MultipleEntitiesCommand(EntityCommand):

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument('id', nargs='+')

    def iter_objects(self, client, model):
        for item in client.options.id:
            yield model.objects.get(item)


class EntityImporter:

    def __call__(self, client, data, model):
        model(**data).save()


class EntityListCommand(EntityCommand):

    command_name = 'ls'

    def __init__(self, columns, **kwargs):
        super().__init__(**kwargs)
        self.columns = columns

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument('-q', '--quiet', action='store_true')

    def __call__(self, client, model):
        qs = self.get_queryset(client, model)

        if client.options.quiet:
            self.list_quiet(qs)
        else:
            self.list_verbose(qs)

    def list_quiet(self, queryset):
        for obj in queryset:
            print(get_object_id(obj))

    def list_verbose(self, queryset):
        header = [column_name for column_name, getter in self.columns]
        rows = [
            [getter(obj) for column_name, getter in self.columns]
            for obj in queryset
        ]
        print_table(header, rows)


class ResourceListCommand(EntityListCommand):

    def __init__(self, *args, **kwargs):
        columns = [
            ('ID', get_object_id),
            ('TYPE', get_object_type),
            ('NAMES', get_object_name),
            ('STATUS', attrgetter('status')),
            ('HEALTH', attrgetter('health')),
        ]
        super().__init__(*args, columns=columns, **kwargs)


class ListGroupMembersCommand(ResourceListCommand, SingleEntityCommand):

    command_name = 'members'

    def get_queryset(self, client, model):
        obj = self.get_object(client, model)
        return obj.members()


class EntityGetCommand(SingleEntityCommand):

    command_name = 'get'

    def __call__(self, client, model):
        obj = self.get_object(client, model)
        yaml_dump(obj)


class EntityRemoveCommand(MultipleEntitiesCommand):

    command_name = 'rm'

    def __call__(self, client, model):
        for obj in self.iter_objects(client, model):
            obj.delete()


class EntityHandler(metaclass=abc.ABCMeta):

    importer = None

    @property
    @abc.abstractmethod
    def model(self):
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def entity_name(self):
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def commands(self):
        raise NotImplementedError

    def add_arguments(self, parser):
        subparsers = parser.add_subparsers(dest='command')
        for command in self.commands:
            command_parser = subparsers.add_parser(command.command_name)
            command_parser.set_defaults(command=functools.partial(command, model=self.model))
            command.add_arguments(command_parser)


class ImportCommand(TopLevelCommand):

    command_name = 'import'

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument('-f', '--file', type=argparse.FileType(), required=True)

    def __call__(self, client):
        with client.options.file as fp:
            document = yaml_load(fp)

        if isinstance(document, list):
            self.import_all(client, document)
        else:
            self.import_one(client, document)

    def import_all(self, client, lst):
        for item in lst:
            self.import_one(client, item)

    def import_one(self, client, spec):
        if not isinstance(spec, dict):
            raise TypeError(type(spec).__name__)
        if not spec:
            raise ValueError('Empty specification')
        if len(spec) > 1:
            raise ValueError('Too many items')

        entity_name, = spec
        entity_spec = spec[entity_name]

        for entity_handler in client.entity_handlers:
            if entity_handler.entity_name == entity_name and entity_handler.importer is not None:
                entity_handler.importer(client, data=entity_spec, model=entity_handler.model)
                return

        raise ValueError(entity_name)


class ApplicationImporter(EntityImporter):

    _component_link_re = re.compile(
        r"""
        ^\s*
        ([\w._-]+)                  # Source component
        (?:
            \s*=>\s*                # Arrow (=>)
            ([\w._-]+)\s*           # Destination component
            \[\s*([\w._-]+)\s*\]    # Destination service
        )?
        \s*$
        """,
        re.VERBOSE)

    _exposed_service_re = re.compile(
        r"""
        ^\s*
        ([\w._-]+)\s*           # Component
        \[\s*([\w._-]+)\s*\]    # Service
        \s*$
        """,
        re.VERBOSE)

    def __call__(self, client, data, model):
        api_data = self.parse(data)
        super().__call__(client, api_data, model)

    def parse(self, data):
        result = {}

        if 'name' in data:
            result['name'] = data['name']

        if 'components' in data:
            components = set()
            links = []

            for link_spec in data['components']:
                src_component, dest_component, dest_service = self.parse_component_link(link_spec)
                components.add(src_component)
                if dest_component:
                    components.add(dest_component)
                    links.append({
                        'src_component': src_component,
                        'dest_component': dest_component,
                        'dest_service': dest_service,
                    })

            result['components'] = list(components)
            result['links'] = links

        if 'expose' in data:
            expose = []

            for service_spec in data['expose']:
                component, service = self.parse_exposed_service(service_spec)
                expose.append({'component': component, 'service': service})

            result['expose'] = expose

        return result

    def parse_component_link(self, link_spec):
        return self._component_link_re.match(link_spec).groups()

    def parse_exposed_service(self, service_spec):
        return self._exposed_service_re.match(service_spec).groups()


class AgentHandler(EntityHandler):

    model = Agent
    entity_name = 'agent'

    commands = [
        EntityListCommand([
            ('ID', get_object_id)
        ]),
        EntityGetCommand(),
    ]


class ApplicationHandler(EntityHandler):

    model = Application
    entity_name = 'application'

    commands = [
        EntityListCommand([
            ('ID', get_object_id),
            ('NAME', get_object_name),
        ]),
        EntityGetCommand(),
        EntityRemoveCommand(),
    ]

    importer = ApplicationImporter()


class GroupHandler(EntityHandler):

    model = Group
    entity_name = 'group'

    commands = [
        EntityListCommand([
            ('ID', get_object_id),
            ('NAME', get_object_name),
        ]),
        EntityGetCommand(),
        ListGroupMembersCommand(),
        EntityRemoveCommand(),
    ]

    importer = EntityImporter()


class ProcedureHandler(EntityHandler):

    model = Procedure
    entity_name = 'procedure'

    commands = [
        EntityListCommand([
            ('ID', get_object_id),
            ('TYPE', get_object_type),
            ('NAME', get_object_name),
        ]),
        EntityGetCommand(),
        EntityRemoveCommand(),
    ]

    importer = EntityImporter()


class ResourceHandler(EntityHandler):

    model = Resource
    entity_name = 'resource'

    commands = [
        ResourceListCommand(),
        EntityGetCommand(),
    ]


class TriggerRunCommand(EntityCommand):

    command_name = 'run'

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument('-d', '--detach', action='store_true')
        parser.add_argument('-k', '--keep', action='store_true')

        parser.add_argument(
            '-o', '--option', dest='options',
            type=self._parse_trigger_arg, action='append', default=[])
        parser.add_argument(
            '-x', '--param', dest='params',
            type=self._parse_trigger_arg, action='append', default=[])
        parser.add_argument('-t', '--target')

        procedure_group = parser.add_mutually_exclusive_group(required=True)
        procedure_group.add_argument('-p', '--procedure')
        procedure_group.add_argument('-c', '--content')

    def _parse_trigger_arg(self, arg):
        parts = arg.split('=', 1)
        if len(parts) == 1:
            key = arg
            value = True
        else:
            key, value = parts
            value = yaml_load(value)
        return key, value

    def __call__(self, client, model):
        obj = model(
            procedure=client.options.procedure,
            content=client.options.content,
            options=dict(client.options.options),
            params=dict(client.options.params),
            target=client.options.target)
        obj.save()

        if not client.options.detach:
            obj.wait(delete=not client.options.keep)


class TriggerHandler(EntityHandler):

    model = Trigger
    entity_name = 'trigger'

    commands = [
        EntityListCommand([
            ('ID', get_object_id),
            ('TYPE', get_object_type),
            ('STATUS', get_object_status),
        ]),
        EntityGetCommand(),
        EntityRemoveCommand(),
        TriggerRunCommand(),
    ]


class StormCtl(CommandLineClient):

    top_level_commands = [
        ImportCommand(),
    ]

    entity_handlers = [
        AgentHandler(),
        ApplicationHandler(),
        GroupHandler(),
        ProcedureHandler(),
        ResourceHandler(),
        TriggerHandler(),
    ]

    def add_arguments(self, parser):
        super().add_arguments(parser)

        subparsers = parser.add_subparsers(dest='command')

        for command in self.top_level_commands:
            command_parser = subparsers.add_parser(command.command_name)
            command_parser.set_defaults(command=command)
            command.add_arguments(command_parser)

        for entity in self.entity_handlers:
            entity_parser = subparsers.add_parser(entity.entity_name)
            entity_parser.set_defaults(entity=entity)
            entity.add_arguments(entity_parser)

    def run(self):
        command = self.options.command
        command(self)


if __name__ == '__main__':
    StormCtl.main()
