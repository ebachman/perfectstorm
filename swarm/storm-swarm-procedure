#!/usr/bin/env python3

import argparse
import io
import json
import logging
import shlex
import subprocess
import textwrap
import yaml

from stormlib import Resource, events
from stormlib.exceptions import StormValidationError, StormObjectNotFound
from stormlib.executors import (
    ProcedureExecutor,
    ProcedureRunner,
    ThreadedJobsExecutor,
)

from stormswarm import SwarmMixin
from stormswarm.client import SwarmClient

log = logging.getLogger(__name__)


def run_subprocess(args):
    sh_command = ' '.join(shlex.quote(arg) for arg in args)

    try:
        proc = subprocess.run(
            args,
            input='',
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
            check=True)
    except subprocess.CalledProcessError as exc:
        output = '\n' + exc.output if exc.output else ''
        log.debug(
            'Command exited with status %s:\n%s%s',
            exc.returncode, sh_command, output)
        raise

    output = '\n' + proc.stdout if proc.stdout else ''
    log.debug('%s%s', sh_command, output)

    return proc


class SwarmServiceExecEmulator(SwarmMixin):

    SHELL_SCRIPT_TEMPLATE = textwrap.dedent('''\
        post() {{
          curl -s --unix-socket /var/run/docker.sock \\
            -H 'Content-Type: application/json' \\
            -d "$1" "http://localhost/$2"
        }}
        post {exec_data} "containers/{container_id}/exec"
        exec_id=$(post {exec_data} "containers/{container_id}/exec" | \\
            grep -Eo '\\<[0-9a-f]{{64}}\\>')
        post {start_data} "exec/$exec_id/start"
    ''').strip()

    def __init__(self, swarm, args):
        super().__init__(swarm)
        self.parse_args(args)

    def parse_args(self, args):
        output = io.StringIO()

        class ArgumentParser(argparse.ArgumentParser):

            def _print_message(self, message, file=None):
                if message:
                    output.write(message)

        parser = ArgumentParser()

        parser.add_argument('-d', '--detach', action='store_true')
        parser.add_argument('-e', '--env', action='append')
        parser.add_argument('--privileged', action='store_true')
        parser.add_argument('-u', '--user')
        parser.add_argument('-w', '--workdir')
        parser.add_argument('task')
        parser.add_argument('command')

        try:
            self.options, extra_args = parser.parse_known_args(args)
        except SystemExit as exc:
            raise subprocess.CalledProcessError(
                returncode=exc.code, cmd=args, output=output.getvalue())

        self.options.args = extra_args

        self.task = Resource.objects.get(
            type='swarm-task',
            names=self.options.task,
            cluster=self.swarm.cluster_id)
        self.node = Resource.objects.get(self.task.host)

    def get_create_command(self):
        container_id = (
            self.task.snapshot['Status']['ContainerStatus']['ContainerID'])

        exec_data = json.dumps({
            'AttachStdin': False,
            'AttachStdout': False,
            'AttachStderr': False,
            'Tty': False,
            'Cmd': [
                self.options.command,
                *self.options.args,
            ],
            'Env': self.options.env,
            'Privileged': self.options.privileged,
            'User': self.options.user,
            'WorkingDir': self.options.workdir,
        })

        start_data = json.dumps({
            'Detach': self.options.detach,
            'Tty': False,
        })

        shell_script = self.SHELL_SCRIPT_TEMPLATE.format(
            container_id=shlex.quote(container_id),
            exec_data=shlex.quote(exec_data),
            start_data=shlex.quote(start_data),
        )

        return [
            'docker',
            '--host', self.swarm.address,
            'service', 'create',
            '--detach',
            '--restart-condition', 'none',
            '--constraint', 'node.id==' + self.node.snapshot['ID'],
            '--mount',
            'type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock',
            '--label', 'storm-swarm-exec=yes',
            '--label', 'storm-swarm-exec-task=' + self.options.task,
            '--label', 'storm-swarm-exec-command=' + self.options.command,
            'appropriate/curl',
            'sh', '-euc', shell_script,
        ]

    def get_remove_command(self, service_id):
        return [
            'docker',
            '--host', self.swarm.address,
            'service', 'rm', service_id,
        ]

    def run(self):
        create_cmd = self.get_create_command()

        with events.stream() as event_stream:
            proc = run_subprocess(create_cmd)
            service_id = proc.stdout.strip()
            self.wait(service_id, event_stream)

        rm_cmd = self.get_remove_command(service_id)
        run_subprocess(rm_cmd)

    def wait(self, service_id, event_stream):
        # Wait for the helper service to appear
        event_filter = events.EventFilter([
            events.EventMask('created', 'resource', None, [service_id]),
        ])
        event_stream = event_filter(event_stream)
        for event in event_stream:
            helper_service = event.entity.retrieve()
            break

        # Wait for the helper task to appear
        event_filter.clear()
        event_filter.register_all([
            events.EventMask('created', 'resource'),
            events.EventMask('updated', 'resource', helper_service.id),
            events.EventMask('deleted', 'resource', helper_service.id),
        ])
        for event in event_stream:
            try:
                resource = event.entity.retrieve()
            except StormObjectNotFound:
                return
            if (resource.type == 'swarm-task' and
                    resource.parent == helper_service.id):
                helper_task = resource
                break

        # Check if the task is complete
        if helper_task.status in ('stopped', 'error'):
            return

        # Wait for the helper task to complete
        event_filter.clear()
        event_filter.register_all([
            events.EventMask('updated', 'resource', helper_task.id),
            events.EventMask('deleted', 'resource', helper_task.id),
        ])
        for event in event_stream:
            try:
                helper_task.reload()
            except StormObjectNotFound:
                return
            if helper_task.status in ('stopped', 'error'):
                return


class SwarmProcedureRunner(SwarmMixin, ProcedureRunner):

    def run(self):
        outputs = []

        try:
            for args in self.list_commands():
                outputs.append(self.run_command(args))
        except subprocess.CalledProcessError as exc:
            outputs.append(exc.output)
            self.fail({'outputs': outputs})
        else:
            self.complete({'outputs': outputs})

    def list_commands(self):
        commands = yaml.load(self.job.content)
        if not isinstance(commands, list):
            raise StormValidationError(
                'expected a list of commands')

        result = []

        for args in commands:
            if isinstance(args, str):
                args = shlex.split(args)
            if (not isinstance(args, list) or
                    not all(isinstance(arg, str) for arg in args)):
                raise StormValidationError(
                    'each command must be a string or a list of strings')
            result.append(args)

        return result

    def run_command(self, args):
        log.debug('Executing: %s', ' '.join(shlex.quote(arg) for arg in args))

        if args[:2] == ['service', 'exec']:
            emulator = SwarmServiceExecEmulator(self.swarm, args[2:])
            return emulator.run()

        proc = run_subprocess(['docker', '--host', self.swarm.address, *args])
        return proc.stdout


class SwarmProcedureExecutor(
        SwarmMixin, ProcedureExecutor, ThreadedJobsExecutor):

    procedure_type = 'swarm'

    def get_pending_jobs(self):
        qs = super().get_pending_jobs()
        return qs.filter(target=self.swarm.cluster_id)

    def get_procedure_runner(self, agent, job):
        return SwarmProcedureRunner(self.swarm, agent, job)


class SwarmProcedureClient(SwarmClient):

    role = 'procedure'

    configure_loggers = [__name__]

    def run(self):
        log.info('storm-swarm-procedure version 0.1')
        log.info('Docker Swarm: {}'.format(self.swarm.address))

        executor = SwarmProcedureExecutor(
            swarm=self.swarm, agent=self.agent)
        executor()


if __name__ == '__main__':
    SwarmProcedureClient().main()
